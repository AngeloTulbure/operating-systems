import java.util.Random;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Monitor {

	private Lock lock = new ReentrantLock();
	private final int nord=0;
	private final int sud=1;
	private Condition []codaA	 = new Condition[2]; 
	private Condition coda_pedoni = lock.newCondition();
	
	private int sosp_nord =0;
	private int[] sospA = new int[2];
	private int sosp_pedoni=0;
	
	private final int max;
	private int sulponte=0;
	private int[] auto_corr = new int[2];
	private Random r;
	
	
	public Monitor(int max, Random r)
	{
		this.max = max;
		this.r=r;
		sospA[nord]=0;
		sospA[sud]=0;
		auto_corr[nord]=0;
		auto_corr[sud]=0;
		codaA[nord]=lock.newCondition();
		codaA[sud]=lock.newCondition();
		
	}
	
	public void inizio_transitoA(int direzione) throws InterruptedException
	{
		lock.lock();
		try
		{
			if(direzione==nord)//nord
			{
				
				
				while((auto_corr[sud]>0) || (sulponte+10)>max || sosp_pedoni>0)
				{	sospA[nord]++;
					codaA[nord].await();
					sospA[nord]--;
				}
				System.out.println("A entro, dir N");
				sulponte=sulponte+10;
				auto_corr[nord]++;
				
			}
			else // direzione sud
			{	while((auto_corr[nord]>0) || (sulponte+10)>max || sosp_pedoni>0)
					{	sospA[sud]++;
						codaA[sud].await();
						sospA[sud]--;
					}
					System.out.println("A entro, dir S");
					sulponte=sulponte+10;
					auto_corr[sud]++;
					
				}
		}
		finally{lock.unlock();}
	}
	
	public void inizio_transitoP() throws InterruptedException
	{
		lock.lock();
		try
		{
			while(sulponte==max)
			{	sosp_pedoni++;
				coda_pedoni.await();
				sosp_pedoni--;
			}
			
			System.out.println("P entro");
			sulponte++;
		}
		finally{lock.unlock();}
	}
	
	public void fine_transitoA(int dir)
	{
		lock.lock();
		try
		{
			
			System.out.println("A in dir "+dir+" esco");
			sulponte=sulponte-10;
			auto_corr[dir]--;
			
			
			if(sosp_pedoni>0)
				coda_pedoni.signalAll();			
			if ((auto_corr[dir]==0) && (sospA[other(dir)]>0))
				codaA[other(dir)].signalAll();
			else if(sospA[dir]>0)
				codaA[dir].signal();
		}
		finally{lock.unlock();}
	}	
	public void fine_transitoP()
	//true:auto, false:pedone
	{
		lock.lock();
		try
		{
			System.out.println("P esco");
			sulponte--;
			if(sosp_pedoni>0)
				coda_pedoni.signal();			
			else if(max-sulponte==10) // c'Ã¨ posto per una nuova auto
			{	int d=r.nextInt(2); // decido in modo casuale quale direzione riattivare
				if (auto_corr[other(d)]==0 && sospA[d]>0) // se posso svegliare in direzione d la sveglio
					codaA[d].signal();
				else if(auto_corr[d]==0 && sospA[other(d)]>0)// altrimenti se posso svegliare in direzione opposta a d, la sveglio
					codaA[other(d)].signal();
			}
		}
		finally{lock.unlock();}
	}
	
	 int other (int direzione)
	 { if (direzione==nord)
		 return sud;
	 else
		 return nord;
	 }
}